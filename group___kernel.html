<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>API Reference: Kernel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="quarktslogo.jfif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">API Reference
   &#160;<span id="projectnumber">v7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___kernel.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Kernel</div>  </div>
</div><!--header-->
<div class="contents">

<p>Kernel API interface to create/remove tasks and perform special OS operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga33bd7afc6bdd5e8a995d2cb50e006e3a"><td class="memItemLeft" align="right" valign="top"><a id="ga33bd7afc6bdd5e8a995d2cb50e006e3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga33bd7afc6bdd5e8a995d2cb50e006e3a">qLowest_Priority</a></td></tr>
<tr class="memdesc:ga33bd7afc6bdd5e8a995d2cb50e006e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro directive to indicate the lowest priority level. <br /></td></tr>
<tr class="separator:ga33bd7afc6bdd5e8a995d2cb50e006e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13bec7f4284d45c97f512c83ed9b7744"><td class="memItemLeft" align="right" valign="top"><a id="ga13bec7f4284d45c97f512c83ed9b7744"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga13bec7f4284d45c97f512c83ed9b7744">qMedium_Priority</a></td></tr>
<tr class="memdesc:ga13bec7f4284d45c97f512c83ed9b7744"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro directive to indicate the medium priority level. <br /></td></tr>
<tr class="separator:ga13bec7f4284d45c97f512c83ed9b7744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c8bd0870414e10a6e72b743627da5a"><td class="memItemLeft" align="right" valign="top"><a id="ga32c8bd0870414e10a6e72b743627da5a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga32c8bd0870414e10a6e72b743627da5a">qHigh_Priority</a></td></tr>
<tr class="memdesc:ga32c8bd0870414e10a6e72b743627da5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro directive to indicate the highest priority level. <br /></td></tr>
<tr class="separator:ga32c8bd0870414e10a6e72b743627da5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3758e719245db560b090d90fce96301"><td class="memItemLeft" align="right" valign="top"><a id="gae3758e719245db560b090d90fce96301"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#gae3758e719245db560b090d90fce96301">qPeriodic</a></td></tr>
<tr class="memdesc:gae3758e719245db560b090d90fce96301"><td class="mdescLeft">&#160;</td><td class="mdescRight">A directive indicating that the task will run periodically every time its time has expired. <br /></td></tr>
<tr class="separator:gae3758e719245db560b090d90fce96301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773358d89dd96b94fd6dd1e17fc60d23"><td class="memItemLeft" align="right" valign="top"><a id="ga773358d89dd96b94fd6dd1e17fc60d23"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga773358d89dd96b94fd6dd1e17fc60d23">qIndefinite</a></td></tr>
<tr class="memdesc:ga773358d89dd96b94fd6dd1e17fc60d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as qPeriodic. A directive indicating that the task will run periodically every time its time has expired. <br /></td></tr>
<tr class="separator:ga773358d89dd96b94fd6dd1e17fc60d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3940f1fab63750a91ea0c3daf958406"><td class="memItemLeft" align="right" valign="top"><a id="gad3940f1fab63750a91ea0c3daf958406"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#gad3940f1fab63750a91ea0c3daf958406">qSingleShot</a></td></tr>
<tr class="memdesc:gad3940f1fab63750a91ea0c3daf958406"><td class="mdescLeft">&#160;</td><td class="mdescRight">A directive that indicates that the task will be executed only once after its time has expired. <br /></td></tr>
<tr class="separator:gad3940f1fab63750a91ea0c3daf958406"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa56cdd54d47ff41d77ca2526516fdf1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#gaa56cdd54d47ff41d77ca2526516fdf1d">qOS_Setup</a> (const <a class="el" href="group___clock.html#gab5aa8bbf739e2c7b181761ff93d20951">qGetTickFcn_t</a> TickProvider, const <a class="el" href="group___clock.html#gae5a941bcd9940c7bc994aadea2fdc927">qTimingBase_t</a> BaseTimming, <a class="el" href="group___tasks.html#ga4ef3d3efb0a0379f677f8a5744ebb9b4">qTaskFcn_t</a> IdleCallback)</td></tr>
<tr class="memdesc:gaa56cdd54d47ff41d77ca2526516fdf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task Scheduler Setup. This function is required and must be called once in the application main thread before any task is being added to the OS.  <a href="group___kernel.html#gaa56cdd54d47ff41d77ca2526516fdf1d">More...</a><br /></td></tr>
<tr class="separator:gaa56cdd54d47ff41d77ca2526516fdf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73dd6e3250103b4e3631268f8ce629d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga73dd6e3250103b4e3631268f8ce629d2">qOS_Set_IdleTask</a> (<a class="el" href="group___tasks.html#ga4ef3d3efb0a0379f677f8a5744ebb9b4">qTaskFcn_t</a> Callback)</td></tr>
<tr class="memdesc:ga73dd6e3250103b4e3631268f8ce629d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Change the callback for the Idle-task.  <a href="group___kernel.html#ga73dd6e3250103b4e3631268f8ce629d2">More...</a><br /></td></tr>
<tr class="separator:ga73dd6e3250103b4e3631268f8ce629d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ae48d68d34a540d3c50e5673d9c0d3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga2ae48d68d34a540d3c50e5673d9c0d3c">qOS_Scheduler_Release</a> (void)</td></tr>
<tr class="memdesc:ga2ae48d68d34a540d3c50e5673d9c0d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the kernel scheduling. The main thread will continue after the <b>qOS_Run</b> call.  <a href="group___kernel.html#ga2ae48d68d34a540d3c50e5673d9c0d3c">More...</a><br /></td></tr>
<tr class="separator:ga2ae48d68d34a540d3c50e5673d9c0d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94f71ce6c8563013962d9e470402c529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga94f71ce6c8563013962d9e470402c529">qOS_Set_SchedulerReleaseCallback</a> (<a class="el" href="group___tasks.html#ga4ef3d3efb0a0379f677f8a5744ebb9b4">qTaskFcn_t</a> Callback)</td></tr>
<tr class="memdesc:ga94f71ce6c8563013962d9e470402c529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set/Change the scheduler release callback function.  <a href="group___kernel.html#ga94f71ce6c8563013962d9e470402c529">More...</a><br /></td></tr>
<tr class="separator:ga94f71ce6c8563013962d9e470402c529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ac6cbe8d1646f096f5d3fdc0473eeb"><td class="memItemLeft" align="right" valign="top">qBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#gad1ac6cbe8d1646f096f5d3fdc0473eeb">qOS_Notification_Spread</a> (void *eventdata, const <a class="el" href="group___tasks.html#ga9c4db20c03003d10e10b617abcb2cf28">qTask_NotifyMode_t</a> mode)</td></tr>
<tr class="memdesc:gad1ac6cbe8d1646f096f5d3fdc0473eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to spread a notification among all the tasks in the scheduling scheme.  <a href="group___kernel.html#gad1ac6cbe8d1646f096f5d3fdc0473eeb">More...</a><br /></td></tr>
<tr class="separator:gad1ac6cbe8d1646f096f5d3fdc0473eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee35a45322d97b9895ccee746dd9e94"><td class="memItemLeft" align="right" valign="top">qBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga9ee35a45322d97b9895ccee746dd9e94">qOS_Add_Task</a> (<a class="el" href="structq_task__t.html">qTask_t</a> *const Task, <a class="el" href="group___tasks.html#ga4ef3d3efb0a0379f677f8a5744ebb9b4">qTaskFcn_t</a> CallbackFcn, qPriority_t Priority, <a class="el" href="group___clock.html#gac7b81fb14df7cba7c4bc212c6226e1ec">qTime_t</a> Time, qIteration_t nExecutions, qState_t InitialState, void *arg)</td></tr>
<tr class="memdesc:ga9ee35a45322d97b9895ccee746dd9e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task to the scheduling scheme. The task is scheduled to run every <b>Time</b> seconds, <b>nExecutions</b> times and executing <b>CallbackFcn</b> method on every pass.  <a href="group___kernel.html#ga9ee35a45322d97b9895ccee746dd9e94">More...</a><br /></td></tr>
<tr class="separator:ga9ee35a45322d97b9895ccee746dd9e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d747397e555d252dc9fa0da04a01d6f"><td class="memItemLeft" align="right" valign="top">qBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga9d747397e555d252dc9fa0da04a01d6f">qOS_Add_EventTask</a> (<a class="el" href="structq_task__t.html">qTask_t</a> *const Task, <a class="el" href="group___tasks.html#ga4ef3d3efb0a0379f677f8a5744ebb9b4">qTaskFcn_t</a> CallbackFcn, qPriority_t Priority, void *arg)</td></tr>
<tr class="memdesc:ga9d747397e555d252dc9fa0da04a01d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task to the scheduling scheme. This API creates a task with qDisabled state by default , so this task will be oriented to be executed only, when asynchronous events occurs. However, this behavior can be changed in execution time using <b>qTask_Set_Time</b> or <b>qTask_Set_Iterations</b>.  <a href="group___kernel.html#ga9d747397e555d252dc9fa0da04a01d6f">More...</a><br /></td></tr>
<tr class="separator:ga9d747397e555d252dc9fa0da04a01d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadaa6b0192ebad11103849f5305f389a"><td class="memItemLeft" align="right" valign="top">qBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#gaadaa6b0192ebad11103849f5305f389a">qOS_Add_StateMachineTask</a> (<a class="el" href="structq_task__t.html">qTask_t</a> *const Task, <a class="el" href="structq_s_m__t.html">qSM_t</a> *m, qPriority_t Priority, <a class="el" href="group___clock.html#gac7b81fb14df7cba7c4bc212c6226e1ec">qTime_t</a> Time, qState_t InitialTaskState, void *arg)</td></tr>
<tr class="memdesc:gaadaa6b0192ebad11103849f5305f389a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task to the scheduling scheme running a dedicated state-machine. The task is scheduled to run every <b>Time</b> seconds in qPeriodic mode. The event info will be available as a generic pointer inside the <b>Data</b> field of the <a class="el" href="structq_s_m___handler__t.html" title="The state callback argument to handle the state-machine dinamics and provide execution information....">qSM_Handler_t</a> argument.  <a href="group___kernel.html#gaadaa6b0192ebad11103849f5305f389a">More...</a><br /></td></tr>
<tr class="separator:gaadaa6b0192ebad11103849f5305f389a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a55cf73aad1c9980bbc425b074bb7c1"><td class="memItemLeft" align="right" valign="top">qBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga3a55cf73aad1c9980bbc425b074bb7c1">qOS_Add_ATCLITask</a> (<a class="el" href="structq_task__t.html">qTask_t</a> *const Task, <a class="el" href="structq_a_t_c_l_i__t.html">qATCLI_t</a> *cli, qPriority_t Priority)</td></tr>
<tr class="memdesc:ga3a55cf73aad1c9980bbc425b074bb7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task to the scheduling scheme running an AT Command Parser. Task will be scheduled as an event-triggered task. The parser address will be stored in the TaskData storage-Pointer.  <a href="group___kernel.html#ga3a55cf73aad1c9980bbc425b074bb7c1">More...</a><br /></td></tr>
<tr class="separator:ga3a55cf73aad1c9980bbc425b074bb7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d3b11b689fa9df89cf8ac4023482765"><td class="memItemLeft" align="right" valign="top">qBool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#ga4d3b11b689fa9df89cf8ac4023482765">qOS_Remove_Task</a> (<a class="el" href="structq_task__t.html">qTask_t</a> *const Task)</td></tr>
<tr class="memdesc:ga4d3b11b689fa9df89cf8ac4023482765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the task from the scheduling scheme.  <a href="group___kernel.html#ga4d3b11b689fa9df89cf8ac4023482765">More...</a><br /></td></tr>
<tr class="separator:ga4d3b11b689fa9df89cf8ac4023482765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb65854f215616a8cdf27b1a01f2ab12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___kernel.html#gabb65854f215616a8cdf27b1a01f2ab12">qOS_Run</a> (void)</td></tr>
<tr class="memdesc:gabb65854f215616a8cdf27b1a01f2ab12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the scheduling scheme. It must be called once after the task pool has been defined.  <a href="group___kernel.html#gabb65854f215616a8cdf27b1a01f2ab12">More...</a><br /></td></tr>
<tr class="separator:gabb65854f215616a8cdf27b1a01f2ab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Kernel API interface to create/remove tasks and perform special OS operations. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3a55cf73aad1c9980bbc425b074bb7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a55cf73aad1c9980bbc425b074bb7c1">&#9670;&nbsp;</a></span>qOS_Add_ATCLITask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qBool_t qOS_Add_ATCLITask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_task__t.html">qTask_t</a> *const&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structq_a_t_c_l_i__t.html">qATCLI_t</a> *&#160;</td>
          <td class="paramname"><em>cli</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qPriority_t&#160;</td>
          <td class="paramname"><em>Priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task to the scheduling scheme running an AT Command Parser. Task will be scheduled as an event-triggered task. The parser address will be stored in the TaskData storage-Pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Task</td><td>A pointer to the task node. </td></tr>
    <tr><td class="paramname">cli</td><td>A pointer to the AT Command Line Inteface instance. </td></tr>
    <tr><td class="paramname">Priority</td><td>Task priority Value. [0(min) - Q_PRIORITY_LEVELS(max)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns qTrue on success, otherwise returns qFalse. </dd></dl>

</div>
</div>
<a id="ga9d747397e555d252dc9fa0da04a01d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d747397e555d252dc9fa0da04a01d6f">&#9670;&nbsp;</a></span>qOS_Add_EventTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qBool_t qOS_Add_EventTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_task__t.html">qTask_t</a> *const&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___tasks.html#ga4ef3d3efb0a0379f677f8a5744ebb9b4">qTaskFcn_t</a>&#160;</td>
          <td class="paramname"><em>CallbackFcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qPriority_t&#160;</td>
          <td class="paramname"><em>Priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task to the scheduling scheme. This API creates a task with qDisabled state by default , so this task will be oriented to be executed only, when asynchronous events occurs. However, this behavior can be changed in execution time using <b>qTask_Set_Time</b> or <b>qTask_Set_Iterations</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Task</td><td>A pointer to the task node. </td></tr>
    <tr><td class="paramname">CallbackFcn</td><td>A pointer to a void callback method with a <a class="el" href="structq_event__t.html" title="The task argument with all the regarding information of the task execution.">qEvent_t</a> parameter as input argument. </td></tr>
    <tr><td class="paramname">Priority</td><td>Task priority Value. [0(min) - Q_PRIORITY_LEVELS(max)] </td></tr>
    <tr><td class="paramname">arg</td><td>Represents the task arguments. All arguments must be passed by reference and cast to (void *). Only one argument is allowed, so, for multiple arguments, create a structure that contains all of the arguments and pass a pointer to that structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns qTrue on success, otherwise returns qFalse. </dd></dl>

</div>
</div>
<a id="gaadaa6b0192ebad11103849f5305f389a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadaa6b0192ebad11103849f5305f389a">&#9670;&nbsp;</a></span>qOS_Add_StateMachineTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qBool_t qOS_Add_StateMachineTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_task__t.html">qTask_t</a> *const&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structq_s_m__t.html">qSM_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qPriority_t&#160;</td>
          <td class="paramname"><em>Priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___clock.html#gac7b81fb14df7cba7c4bc212c6226e1ec">qTime_t</a>&#160;</td>
          <td class="paramname"><em>Time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qState_t&#160;</td>
          <td class="paramname"><em>InitialTaskState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task to the scheduling scheme running a dedicated state-machine. The task is scheduled to run every <b>Time</b> seconds in qPeriodic mode. The event info will be available as a generic pointer inside the <b>Data</b> field of the <a class="el" href="structq_s_m___handler__t.html" title="The state callback argument to handle the state-machine dinamics and provide execution information....">qSM_Handler_t</a> argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Task</td><td>A pointer to the task node. </td></tr>
    <tr><td class="paramname">m</td><td>A pointer to the Finite State-Machine (FSM) object. </td></tr>
    <tr><td class="paramname">Priority</td><td>Task priority Value. [0(min) - Q_PRIORITY_LEVELS(max)] </td></tr>
    <tr><td class="paramname">Time</td><td>Execution interval defined in seconds (floating-point format). For immediate execution (tValue = qTimeImmediate). </td></tr>
    <tr><td class="paramname">InitialTaskState</td><td>: Specifies the initial operational state of the task (qEnabled, qDisabled, qASleep or qAwake(implies qEnabled)). </td></tr>
    <tr><td class="paramname">arg</td><td>Represents the task arguments. All arguments must be passed by reference and cast to (void *). Only one argument is allowed, so, for multiple arguments, create a structure that contains all of the arguments and pass a pointer to that structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns qTrue on success, otherwise returns qFalse. </dd></dl>

</div>
</div>
<a id="ga9ee35a45322d97b9895ccee746dd9e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee35a45322d97b9895ccee746dd9e94">&#9670;&nbsp;</a></span>qOS_Add_Task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qBool_t qOS_Add_Task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_task__t.html">qTask_t</a> *const&#160;</td>
          <td class="paramname"><em>Task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___tasks.html#ga4ef3d3efb0a0379f677f8a5744ebb9b4">qTaskFcn_t</a>&#160;</td>
          <td class="paramname"><em>CallbackFcn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qPriority_t&#160;</td>
          <td class="paramname"><em>Priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___clock.html#gac7b81fb14df7cba7c4bc212c6226e1ec">qTime_t</a>&#160;</td>
          <td class="paramname"><em>Time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qIteration_t&#160;</td>
          <td class="paramname"><em>nExecutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qState_t&#160;</td>
          <td class="paramname"><em>InitialState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task to the scheduling scheme. The task is scheduled to run every <b>Time</b> seconds, <b>nExecutions</b> times and executing <b>CallbackFcn</b> method on every pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Task</td><td>A pointer to the task node. </td></tr>
    <tr><td class="paramname">CallbackFcn</td><td>A pointer to a void callback method with a <a class="el" href="structq_event__t.html" title="The task argument with all the regarding information of the task execution.">qEvent_t</a> parameter as input argument. </td></tr>
    <tr><td class="paramname">Priority</td><td>Task priority Value. [0(min) - Q_PRIORITY_LEVELS(max)] </td></tr>
    <tr><td class="paramname">Time</td><td>Execution interval defined in seconds (floating-point format). For immediate execution (tValue = qTimeImmediate). </td></tr>
    <tr><td class="paramname">nExecutions</td><td>: Number of task executions (Integer value). For indefinite execution (nExecutions = qPeriodic or qIndefinite). Tasks do not remember the number of iteration set initially. After the iterations are done, internal iteration counter is 0. To perform another set of iterations, set the number of iterations again. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Tasks which performed all their iterations put their own state to qDisabled. </dd>
<dd>
Asynchronous triggers do not affect the iteration counter. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InitialState</td><td>: Specifies the initial operational state of the task (qEnabled, qDisabled, qASleep or qAwake(implies qEnabled)). </td></tr>
    <tr><td class="paramname">arg</td><td>Represents the task arguments. All arguments must be passed by reference and cast to (void *). Only one argument is allowed, so, for multiple arguments, create a structure that contains all of the arguments and pass a pointer to that structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns qTrue on success, otherwise returns qFalse. </dd></dl>

</div>
</div>
<a id="gad1ac6cbe8d1646f096f5d3fdc0473eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1ac6cbe8d1646f096f5d3fdc0473eeb">&#9670;&nbsp;</a></span>qOS_Notification_Spread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qBool_t qOS_Notification_Spread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>eventdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___tasks.html#ga9c4db20c03003d10e10b617abcb2cf28">qTask_NotifyMode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to spread a notification among all the tasks in the scheduling scheme. </p>
<dl class="section note"><dt>Note</dt><dd>Operation will be performed in the next scheduling cycle. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventdata</td><td>Specific event user-data. </td></tr>
    <tr><td class="paramname">mode</td><td>the method used to spread the event: <b>qTask_NotifySimple</b> or <b>qTask_NotifyQueued</b>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>qTrue if success. qFalse if any other spread operation is in progress. </dd></dl>

</div>
</div>
<a id="ga4d3b11b689fa9df89cf8ac4023482765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d3b11b689fa9df89cf8ac4023482765">&#9670;&nbsp;</a></span>qOS_Remove_Task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">qBool_t qOS_Remove_Task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structq_task__t.html">qTask_t</a> *const&#160;</td>
          <td class="paramname"><em>Task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the task from the scheduling scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Task</td><td>A pointer to the task node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns qTrue if success, otherwise returns qFalse. </dd></dl>

</div>
</div>
<a id="gabb65854f215616a8cdf27b1a01f2ab12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb65854f215616a8cdf27b1a01f2ab12">&#9670;&nbsp;</a></span>qOS_Run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qOS_Run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the scheduling scheme. It must be called once after the task pool has been defined. </p>
<dl class="section note"><dt>Note</dt><dd>This call keeps the application in an endless loop. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
<a id="ga2ae48d68d34a540d3c50e5673d9c0d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ae48d68d34a540d3c50e5673d9c0d3c">&#9670;&nbsp;</a></span>qOS_Scheduler_Release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qOS_Scheduler_Release </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the kernel scheduling. The main thread will continue after the <b>qOS_Run</b> call. </p>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
<a id="ga73dd6e3250103b4e3631268f8ce629d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73dd6e3250103b4e3631268f8ce629d2">&#9670;&nbsp;</a></span>qOS_Set_IdleTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qOS_Set_IdleTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___tasks.html#ga4ef3d3efb0a0379f677f8a5744ebb9b4">qTaskFcn_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Change the callback for the Idle-task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Callback</td><td>A pointer to a void callback method with a <a class="el" href="structq_event__t.html" title="The task argument with all the regarding information of the task execution.">qEvent_t</a> parameter as input argument. To disable pass NULL as argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
<a id="ga94f71ce6c8563013962d9e470402c529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94f71ce6c8563013962d9e470402c529">&#9670;&nbsp;</a></span>qOS_Set_SchedulerReleaseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qOS_Set_SchedulerReleaseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___tasks.html#ga4ef3d3efb0a0379f677f8a5744ebb9b4">qTaskFcn_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set/Change the scheduler release callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Callback</td><td>A pointer to a void callback method with a <a class="el" href="structq_event__t.html" title="The task argument with all the regarding information of the task execution.">qEvent_t</a> parameter as input argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
<a id="gaa56cdd54d47ff41d77ca2526516fdf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa56cdd54d47ff41d77ca2526516fdf1d">&#9670;&nbsp;</a></span>qOS_Setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qOS_Setup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___clock.html#gab5aa8bbf739e2c7b181761ff93d20951">qGetTickFcn_t</a>&#160;</td>
          <td class="paramname"><em>TickProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___clock.html#gae5a941bcd9940c7bc994aadea2fdc927">qTimingBase_t</a>&#160;</td>
          <td class="paramname"><em>BaseTimming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___tasks.html#ga4ef3d3efb0a0379f677f8a5744ebb9b4">qTaskFcn_t</a>&#160;</td>
          <td class="paramname"><em>IdleCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task Scheduler Setup. This function is required and must be called once in the application main thread before any task is being added to the OS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TickProvider</td><td>The function that provides the tick value. If the user application uses the <b>qClock_SysTick</b> from the ISR, this parameter can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function should take void and return a 32bit value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">BaseTimming</td><td>(Optional) This parameter specifies the ISR background timer base time. This can be the period in seconds(Floating-point format) or frequency in Herzt(Only if Q_SETUP_TICK_IN_HERTZ is enabled). </td></tr>
    <tr><td class="paramname">IdleCallback</td><td>Callback function to the Idle Task. To disable the Idle Task activities, pass NULL as argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
