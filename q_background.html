<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Doxygen Awesome" />
<meta property="og:image" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta property="og:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta name="twitter:title" content="Doxygen Awesome" />
<meta name="twitter:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<!-- END twitter metadata -->
<title>OS: Background</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/jothepro/doxygen-awesome-css" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="quarktslogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OS
   &#160;<span id="projectnumber">v7</span>
   </div>
   <div id="projectbrief">Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('q_background.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Background </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#q_about">About the OS</a><ul><li class="level2"><a href="#q_license">License</a></li>
<li class="level2"><a href="#q_hardwarecompatibility">Hardware compatibility</a></li>
<li class="level2"><a href="#q_codstandard">Development process and coding starndard</a></li>
<li class="level2"><a href="#q_memusage">Memory usage</a></li>
</ul>
</li>
<li class="level1"><a href="#q_timmingapproach">Timming Approach</a></li>
<li class="level1"><a href="#q_setupkernel">Setting up the OS kernel</a></li>
<li class="level1"><a href="#q_tasks">Tasks</a><ul><li class="level2"><a href="#q_idletask">The idle task</a></li>
<li class="level2"><a href="#q_addtasks">Adding tasks to the scheme</a></li>
<li class="level2"><a href="#q_eventtasks">Event-triggered tasks</a></li>
<li class="level2"><a href="#q_removetask">Removing a task</a></li>
</ul>
</li>
<li class="level1"><a href="#q_runos">Running the OS</a><ul><li class="level2"><a href="#q_releasescheduler">Releasing the scheduler</a></li>
</ul>
</li>
<li class="level1"><a href="#q_globalstates">Global states and scheduling rules</a><ul><li class="level2"><a href="#q_osrules">Rules</a><ul><li class="level3"><a href="#q_os_evenprecedence">Event precedence</a></li>
<li class="level3"><a href="#q_os_operational_states">Additional operational states</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#q_gettingstarted">Getting started</a></li>
<li class="level1"><a href="#q_critical">Critical sections</a></li>
<li class="level1"><a href="#q_os_demo">Demonstrative examples</a><ul><li class="level2"><a href="#q_os_example1">A simple scheduling</a></li>
<li class="level2"><a href="#q_os_example2">Using the task argument</a></li>
</ul>
</li>
<li class="level1"><a href="#q_configmacros">Configuration macros</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="q_about"></a>
About the OS</h1>
<p >QuarkTS is an open-source operating system that is built on top of a cooperative quasistatic scheduler. Its simplified kernel implements a specialized round-robin scheme using a linked-chain approach and an event-queue to provide true FIFO priority scheduling.</p>
<p ><b> <b>Why</b> cooperative? </b></p>
<p >Rather than having preemption, tasks manage their own life-cycle. This bring significant benefits, fewer re-entrance problems are encountered, because tasks cannot be interrupted arbitrarily by other tasks, but only at positions permitted by the programmer, so you mostly do not need to worry about pitfalls of the concurrent approach(resourcesharing, races, deadlocks, etc...).</p>
<p ><b> What is it made for? </b></p>
<p >The design goal of QuarkTS is to achieve its stated functionality using a small, simple, and (most importantly) robust implementation to make it suitable on resourceconstrained microcontrollers, where a full-preemptive RTOS is an overkill and their inclusion adds unnecessary complexity to the firmware development. In addition with a state-machines support, co-routines, time control and the inter-task communication primitives, QuarkTS provides a modern environment to build stable and predictable event-driven multitasking embedded software. Their modularity and reliability make this OS a great choice to develop efficiently a wide range of applications in low-cost devices, including automotive controls, monitoring and Internet of Things</p>
<p ><b>Why should I choose it?</b></p>
<p >QuarkTS is not intended to replace o compete with the other great and proven RTOS options already available today, for example FreeRTOS or MicroC/OS-II, in fact, you should check these options first. However, due to its size and features, is intended to play in the space between RTOSes and bare-metal. QuarkTS was written for embedded developers who want more functionality than what existing task schedulers offer, but want to avoid the space and complexity of a full RTOS, but keeping the taste of a robust and safe one.</p>
<h2><a class="anchor" id="q_license"></a>
License</h2>
<p >QuarkTS is licensed under the MIT License. You may copy, distribute and modify the software without any restriction, including without limitation the rights to to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the OS, and to permit persons to whom the OS is furnished to do so. This OS is provided as is in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE .</p>
<p >For more details, see the MIT License line by line here. <a href="https://writing.kemitchell.com/2016/09/21/MIT-License-Line-by-Line.html" style="font-weight:bold">MIT License</a></p>
<h2><a class="anchor" id="q_hardwarecompatibility"></a>
Hardware compatibility</h2>
<p >QuarkTS has no direct hardware dependencies, so it is portable to many platforms and C compilers.</p>
<p >The following cores have been powered with QuarkTS successfully:</p>
<ul>
<li>ARM cores(ATMEL, STM32, LPC, Kinetis, Nordic and others)</li>
<li>8Bit AVR, 8051, STM8</li>
<li>HCS12, ColdFire, MSP430</li>
<li>PIC (PIC24, dsPIC, 32MX, 32MZ)</li>
</ul>
<h2><a class="anchor" id="q_codstandard"></a>
Development process and coding starndard</h2>
<p >QuarkTS is developed using a formal and rigorous process framed in compliance of the <a href="https://www.misra.org.uk/" style="font-weight:bold">MISRA C 2012</a> and <a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard" style="font-weight:bold">SEI CERT coding standard</a> guidelines and complemented with multiple static-analysis checks targered to safe critical applications.</p>
<p >Simply using QuarkTS in an application, does not mean developers can make a claim related to the development process and compliance of the OS to any requirements or product specification, without first, following a recognized system wide conformance verification process. Conformance evidence must then be presented, audited and accepted by a recognized and relevant independent assessment organization. Without undergoing this process of due diligence, no claim can be made as to the suitability of QuarkTS to be used in any safety or otherwise commercially critical application.</p>
<p >Besides the previous information, the OS sets the following clarifications regarding coding policies and naming convention:</p>
<ul>
<li>All the QuarkTS implementation follows the ANSI C99 standard strictly.</li>
<li>Dynamic memory allocation is banned to conform the industry standards for safety-critical software: MISRA-C, DO178B, IEC 61508, ISO 26262 and so on.</li>
<li>Because errors in string manipulation have long been recognized as a leading source of buffer overflows in C, a number of mitigation strategies have been devised. These include mitigation strategies designed to prevent buffer overflows from occurring and strategies designed to detect buffer overflows and securely recover without allowing the failure to be exploited.</li>
<li>In line with MISRA guides and for portability between platforms, we use the <code>stdint.h</code> with typedefs that indicate size and signedness in place of the basic types.</li>
<li>In line with MISRA guides, unqualified standard <code>char</code> and <code>char*</code> types are only permitted to hold ASCII characters and strings respectively.</li>
<li>The <code>_t</code> suffix its used to denote a type definition (i.e <code>qBool_t</code> , <code><a class="el" href="structq_task__t.html" title="A task node object.">qTask_t</a></code> , <code>size_t</code>, ...).</li>
<li>Functions, macros, enum values and data-types are prefixed q. (i.e. <code>qFunction</code>, <code>qEnumValue</code>, <code>QCONSTANT</code>, <code>qType_t</code>, ...)</li>
<li>Other than the pre-fix, most macros used for constants are written in all upper case.</li>
<li>Almost all functions returns a boolean value of type <code>qBool_t</code>, where a <code>qTrue</code> - <code>1u</code> value indicates a successful procedure and <code>qFalse</code> - <code>0u</code>, the failure of the procedure</li>
</ul>
<h2><a class="anchor" id="q_memusage"></a>
Memory usage</h2>
<p >As a quasi-static scheduler is implemented here, dynamic scheduling is not required and the assignment of tasks must be done before program execution begins. The kernel is designed to allow unlimited tasks and kernel objects, but of course, the whole application will be constrained by the memory specifications of the embedded system.</p>
<p >The kernel's memory footprint can be scaled down to contain only the features required for your application, typically 3.7 KBytes of code space and less than 1 KByte of data space.</p>
<center> <a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>OS Memory footprint (Measured in a 32-bit MCU)</caption>
<tr>
<th>Functionality </th><th>Size(bytes) </th></tr>
<tr>
<td>Kernel, scheduler and task management </td><td>2637 </td></tr>
<tr>
<td>A task node (<code><a class="el" href="structq_task__t.html" title="A task node object.">qTask_t</a></code>) </td><td>68 </td></tr>
<tr>
<td>Finite State machines(FSM) handling and related APIs </td><td>314 </td></tr>
<tr>
<td>A FSM object (<code><a class="el" href="structq_s_m__t.html" title="A FSM(Finite State Machine) object.">qSM_t</a></code>) </td><td>100 </td></tr>
<tr>
<td>A state object (<code><a class="el" href="structq_s_m___state__t.html" title="A state object.">qSM_State_t</a></code>) </td><td>36 </td></tr>
<tr>
<td>STimers handling and related APIs </td><td>258 </td></tr>
<tr>
<td>A STimer object (<code><a class="el" href="structq_s_timer__t.html" title="A STimer(Software Timer) object.">qSTimer_t</a></code>) </td><td>8 </td></tr>
<tr>
<td>Queues handling and related APIs </td><td>544 </td></tr>
<tr>
<td>A queue object (<code><a class="el" href="structq_queue__t.html" title="A Queue object.">qQueue_t</a></code>) </td><td>28 </td></tr>
<tr>
<td>Memory management </td><td>407 </td></tr>
<tr>
<td>A memory pool </td><td>28 </td></tr>
<tr>
<td>The AT Command Line Interface </td><td>1724 </td></tr>
<tr>
<td>An AT-CLI instance (<code><a class="el" href="structq_a_t_c_l_i__t.html" title="An AT Command Line Interface (CLI) object.">qATCLI_t</a></code>) </td><td>112 </td></tr>
<tr>
<td>An AT-CLI command instance (<code><a class="el" href="structq_a_t_c_l_i___command__t.html" title="An AT-Command object.">qATCLI_Command_t</a></code>) </td><td>24 </td></tr>
<tr>
<td>Remaining utilities </td><td>2980 </td></tr>
</table>
</center><dl class="section note"><dt>Note</dt><dd>Although the kernel does not use dynamically-allocated resources internally, the application writer can create an object in run-time using the safe-heap implementation provided by the memory management module, later described here. Of course, additional checks must be performed to keep the solution safe.</dd></dl>
<h1><a class="anchor" id="q_timmingapproach"></a>
Timming Approach</h1>
<p >The kernel implements a <a href="https://en.wikipedia.org/wiki/Time-triggered_architecture" style="font-weight:bold">Time-Triggered Architecture (TTA)</a> , in which the tasks are triggered by comparing the corresponding task-time with a reference clock. The reference clock must be real-time and follow a monotonic behavior. Usually, all embedded systems can provide this kind of reference with a constant tick generated by a periodic background hardware-timer, typically, at 1Khz (1mS tick).</p>
<p >For this, the kernel allows you to select the reference clock source among these two scenarios:</p>
<ul>
<li>When tick already provided: The reference is supplied by the Hardware Abstraction Layer (HAL) of the device. It is the simplest scenario and it occurs when the framework or SDK of the embedded system includes a HAL-API that obtains the time elapsed since the system starts, usually in milliseconds and taking a 32-bit counter variable.</li>
<li>When the tick is not provided: The application writer should use bare-metal code to configure the device and feed the reference clock manually. Here, a hardware timer should raise an interrupt periodically. After the Interrupt Service Routine(ISR) has been implemented using the platform-dependent code, the <a class="el" href="group__qclock.html#gacdc3d27983dcc08e28d9eb9844a55c53" title="Feed the system tick.">qClock_SysTick()</a> API must be called inside. It is recommended that the reserved ISR should only be used by QuarkTS.</li>
</ul>
<h1><a class="anchor" id="q_setupkernel"></a>
Setting up the OS kernel</h1>
<p >The <a class="el" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313" title="Task Scheduler Setup. This function is required and must be called once in the application main threa...">qOS_Setup()</a> function should be the first call to the OS APIs. <a class="el" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313" title="Task Scheduler Setup. This function is required and must be called once in the application main threa...">qOS_Setup()</a> prepares the kernel instance, sets the reference clock, defines the Idle-Task callback and allocates the stack for the internal queue.</p>
<dl class="section note"><dt>Note</dt><dd>This call is mandatory and must be called once in the application main thread before any kind of interaction with the OS.</dd></dl>
<p>Usage example:</p><ul>
<li>Scenario 1 : When tick is already provided <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;QuarkTS.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;HAL.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TIMER_TICK 0.001 </span><span class="comment">/* 1ms */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( <span class="keywordtype">void</span> ) {</div>
<div class="line">    HAL_Init();</div>
<div class="line">    <a class="code hl_function" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313">qOS_Setup</a>( HAL_GetTick , TIMER_TICK , IdleTask_Callback );</div>
<div class="line">    <span class="comment">// TODO: add Tasks to the scheduler scheme and run the OS</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__qtaskcreation_html_gac97ca3bd669135e0adcf07fcc2852313"><div class="ttname"><a href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313">qOS_Setup</a></div><div class="ttdeci">qBool_t qOS_Setup(const qGetTickFcn_t tFcn, const qTimingBase_t t, qTaskFcn_t idleCallback)</div><div class="ttdoc">Task Scheduler Setup. This function is required and must be called once in the application main threa...</div><div class="ttdef"><b>Definition:</b> qkernel.c:124</div></div>
</div><!-- fragment --></li>
<li>Scenario 2 : When the tick is not provided <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;QuarkTS.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;DeviceHeader.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TIMER_TICK 0.001 </span><span class="comment">/* 1ms */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Interrupt_Timer0( <span class="keywordtype">void</span> ) {</div>
<div class="line">    <a class="code hl_function" href="group__qclock.html#gacdc3d27983dcc08e28d9eb9844a55c53">qClock_SysTick</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( <span class="keywordtype">void</span> ) {</div>
<div class="line">    MCU_Init();</div>
<div class="line">    HAL_Init();</div>
<div class="line">    <a class="code hl_function" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313">qOS_Setup</a>( NULL , TIMER_TICK , IdleTask_Callback );</div>
<div class="line">    <span class="comment">// TODO: add Tasks to the scheduler scheme and run the OS</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__qclock_html_gacdc3d27983dcc08e28d9eb9844a55c53"><div class="ttname"><a href="group__qclock.html#gacdc3d27983dcc08e28d9eb9844a55c53">qClock_SysTick</a></div><div class="ttdeci">void qClock_SysTick(void)</div><div class="ttdoc">Feed the system tick.</div><div class="ttdef"><b>Definition:</b> qclock.c:90</div></div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="q_tasks"></a>
Tasks</h1>
<p >Like many operating systems, the basic unit of work is the task. Tasks can perform certain functions, which could require periodic or one-time execution, update of specific variables or waiting for specific events. Tasks also could be controlling specific hardware or be triggered by hardware interrupts. In the QuarkTS OS, a task is seen as a node concept that links together:</p>
<ul>
<li>Program code performing specific task activities (callback function)</li>
<li>Execution interval (time)</li>
<li>Number of execution (iterations)</li>
<li>Event-based data</li>
</ul>
<p >The OS uses a Task Control Block (TCB) to represent each task, storing essential information about task management and execution. Part of this information also includes link-pointers that allows it to be part of one of the lists available in the Kernel Control Block (KCB).</p>
<div class="image">
<img src="https://user-images.githubusercontent.com/11412210/195989613-5b4f8970-2645-4324-a11b-70c9ce52061b.png" alt=""/>
<div class="caption">
Task node illustration</div></div>
<p >Each task performs its activities via a callback function and each of them is responsible for supporting cooperative multitasking by being “good neighbors”, i.e., running their callback methods quickly in a non-blocking way and releasing control back to the scheduler as soon as possible (returning).</p>
<p >Every task node, must be defined using the <a class="el" href="structq_task__t.html" title="A task node object.">qTask_t</a> data-type and the callback is defined as a function that returns void and takes a <a class="el" href="structq_event__t.html" title="The task argument with all the regarding information of the task execution.">qEvent_t</a> data structure as its only parameter (This input argument can be used later to get event information, see XXX).</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structq_task__t.html">qTask_t</a> UserTask;</div>
<div class="line"><span class="keywordtype">void</span> UserTask_Callback( <a class="code hl_struct" href="structq_event__t.html">qEvent_t</a> eventdata ) {</div>
<div class="line">    <span class="comment">// TODO : Task code</span></div>
<div class="line">}</div>
<div class="ttc" id="astructq_event__t_html"><div class="ttname"><a href="structq_event__t.html">qEvent_t</a></div><div class="ttdoc">The task argument with all the regarding information of the task execution.</div><div class="ttdef"><b>Definition:</b> qtasks.h:159</div></div>
<div class="ttc" id="astructq_task__t_html"><div class="ttname"><a href="structq_task__t.html">qTask_t</a></div><div class="ttdoc">A task node object.</div><div class="ttdef"><b>Definition:</b> qtasks.h:265</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>All tasks in QuarkTS must ensure their completion to return the CPU control back to the scheduler, otherwise, the scheduler will hold the execution state for that task, preventing the activation of other tasks.</dd></dl>
<h2><a class="anchor" id="q_idletask"></a>
The idle task</h2>
<p >Its a special task loaded by the OS scheduler when there is nothing else to do (no task in the whole scheme has reached the ready state). The idle task is already hard-coded into the kernel, ensuring that at least, one task is able to run. Additionally, the OS setup this task with the lowest possible priority to ensure that does not use any CPU time if there are higher priority application tasks able to run. The idle task doesn't perform any active functions, but the user can decide if it should perform some activities defining a callback function for it. This could be done at the beginning of the kernel setup. Of course, the callback must follow the same function prototype for tasks. </p><dl class="section note"><dt>Note</dt><dd>To disable the idle-task activities, a <code>NULL</code> should be passed as argument on <a class="el" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313" title="Task Scheduler Setup. This function is required and must be called once in the application main threa...">qOS_Setup()</a>.</dd></dl>
<h2><a class="anchor" id="q_addtasks"></a>
Adding tasks to the scheme</h2>
<p >After setting up the kernel with <a class="el" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313" title="Task Scheduler Setup. This function is required and must be called once in the application main threa...">qOS_Setup()</a>, the user can proceed to deploy the multitasking application by adding tasks. If the task node and their respective callback is already defined, the task can be added to the scheme using <a class="el" href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2" title="Add a task to the scheduling scheme. The task is scheduled to run every t seconds,...">qOS_Add_Task()</a>. This API can schedule a task to run every <code>t</code> seconds, <code>n</code> exencutions times and executing the <code>callbackFcn</code> method on every pass.</p>
<p ><b> Caveats: </b></p>
<ol type="1">
<li>A task with Time argument defined in <code>qTimeImmediate</code>, will always get the <code>qReady</code> state in every scheduling cycle, as consequence, the idle task will never gets dispatched.</li>
<li>Tasks do not remember the number of iteration set initially by the <code>nExecutions</code> argument. After the iterations are done, the internal iteration counter decreases until reach the zero. If another set of iterations is needed, the user should set the number of iterations again and resume the task explicitly.</li>
<li>Tasks that performed all their iterations, put their own state to <code>qDisabled</code>. Asynchronous triggers do not affect the iteration counter.</li>
<li>The <code>arg</code> parameter can be used as storage pointer, so, for multiple data, create a structure with the required members and pass a pointer to that structure.</li>
</ol>
<p >Invoking <a class="el" href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2" title="Add a task to the scheduling scheme. The task is scheduled to run every t seconds,...">qOS_Add_Task()</a> is the most generic way to adding tasks to the scheme, supporting a mixture of time-triggered and event-triggered tasks, however, additional simplified API functions are also provided to add specific purpose tasks:</p>
<ul>
<li>Event-triggered only tasks → <a class="el" href="group__qtaskcreation.html#gae296358ea4dd26df7018155eef0cb456" title="Add a task to the scheduling scheme. This API creates a task with a qDisabled state by default,...">qOS_Add_EventTask()</a>.</li>
<li>State-machine tasks → <a class="el" href="group__qtaskcreation.html#gaeea76a6e287011694689c658f7e204ca" title="Add a task to the scheduling scheme running a dedicated state-machine. The task is scheduled to run e...">qOS_Add_StateMachineTask()</a>.</li>
<li>AT Command Line Interface tasks → <a class="el" href="group__qtaskcreation.html#gaf0b51d7213c21c0afbfd4dbce865c6e2" title="Add a task to the scheduling scheme running an AT Command Line Interface. Task will be scheduled as e...">qOS_Add_ATCLITask()</a>.</li>
</ul>
<h2><a class="anchor" id="q_eventtasks"></a>
Event-triggered tasks</h2>
<p >An event-triggered task reacts asynchronously to the occurrence of events in the system, such as external interrupts or changes in the available resources.</p>
<p >The API <a class="el" href="group__qtaskcreation.html#gae296358ea4dd26df7018155eef0cb456" title="Add a task to the scheduling scheme. This API creates a task with a qDisabled state by default,...">qOS_Add_EventTask()</a> is intended to add this kind of tasks, keeping it in a <code>qSuspended</code> state. Only asynchronous events followed by their priority value dictates when a task can change to the <code>qRunning</code> state.</p>
<h2><a class="anchor" id="q_removetask"></a>
Removing a task</h2>
<p >The <a class="el" href="group__qtaskcreation.html#ga4d3b11b689fa9df89cf8ac4023482765" title="Remove the task from the scheduling scheme.">qOS_Remove_Task()</a> function removes the task from the scheduling scheme. This means the task node will be disconnected from the kernel chain, preventing additional overhead provided by the scheduler when it does checks over it and course, preventing from running.</p>
<p ><b> Caveats: </b></p>
<p >Task nodes are variables like any other. They allow your application code to reference a task, but there is no link back the other way and the kernel doesn't know anything about the variables, where the variable is allocated (stack, global, static, etc.) or how many copies of the variable you have made, or even if the variable still exists. So the <a class="el" href="group__qtaskcreation.html#ga4d3b11b689fa9df89cf8ac4023482765" title="Remove the task from the scheduling scheme.">qOS_Remove_Task()</a> API cannot automatically free the resources allocated by the variable. If the task node has been dynamically allocated, the application writer it's responsible to free the memory block after a removal call.</p>
<h1><a class="anchor" id="q_runos"></a>
Running the OS</h1>
<p >After preparing the multitasking environment for your application, a call to <a class="el" href="group__qtaskcreation.html#gabd4b43371d39c5eb82b87f0900f2895a" title="Executes the scheduling scheme. It must be called once after the task pool has been defined.">qOS_Run()</a> is required to execute the scheduling scheme. This function is responsible to run the following OS main components:</p>
<ul>
<li>The Scheduler : Select the tasks to be submitted into the system and decide with of them are able to run.</li>
<li>The Dispatcher : When the scheduler completes its job of selecting ready tasks, it is the dispatcher which takes that task to the running state. This procedure gives a task control over the CPU after it has been selected by the scheduler. This involves the following:<ol type="1">
<li>Preparing the resources before the task execution</li>
<li>Execute the task activities (via the callback function)</li>
<li>Releasing the resources after the task execution</li>
</ol>
</li>
</ul>
<p >The states involved in the interaction between the scheduler and dispatcher are described <a class="el" href="q_background.html#q_globalstates">here</a>.</p>
<dl class="section note"><dt>Note</dt><dd>After calling <a class="el" href="group__qtaskcreation.html#gabd4b43371d39c5eb82b87f0900f2895a" title="Executes the scheduling scheme. It must be called once after the task pool has been defined.">qOS_Run()</a>, the OS scheduler will now be running, and the following line should never be reached, however, the user can optionally release it explicitly with <a class="el" href="group__qtaskcreation.html#ga7ab61e7b82c7d42ec83368c76bcbd9f2" title="Disables the kernel scheduling. The main thread will continue after the qOS_Run() call.">qOS_Scheduler_Release()</a> API function.</dd></dl>
<h2><a class="anchor" id="q_releasescheduler"></a>
Releasing the scheduler</h2>
<p >This functionality must be enabled from the <code>Q_ALLOW_SCHEDULER_RELEASE</code> macro. This API stop the kernel scheduling. In consequence, the main thread will continue after the <a class="el" href="group__qtaskcreation.html#gabd4b43371d39c5eb82b87f0900f2895a" title="Executes the scheduling scheme. It must be called once after the task pool has been defined.">qOS_Run()</a> call.</p>
<p >Although producing this action is not a typical desired behavior in any application, it can be used to handle a critical exception.</p>
<p >When used, the release will take place after the current scheduling cycle finish. The kernel can optionally include a release callback function that can be configured to get called if the scheduler is released. Defining the release callback, will help to take actions over the exception that caused the release action. To perform a release action, the <a class="el" href="group__qtaskcreation.html#ga8bf2fd6a232425e00427e58d8894a475" title="Set/Change the scheduler release callback function.">qOS_Set_SchedulerReleaseCallback()</a> API should be used</p>
<dl class="section note"><dt>Note</dt><dd>When a scheduler release is performed, resources are not freed. After released, the application can invoke the <a class="el" href="group__qtaskcreation.html#gabd4b43371d39c5eb82b87f0900f2895a" title="Executes the scheduling scheme. It must be called once after the task pool has been defined.">qOS_Run()</a> again to resume the scheduling activities</dd></dl>
<h1><a class="anchor" id="q_globalstates"></a>
Global states and scheduling rules</h1>
<p >A task can be in one of the four global states: <code>qRunning</code>, <code>qReady</code>, <code>qSuspended</code> or <code>qWaiting</code>. Each of these states is tracked implicitly by putting the task in one of the associated kernel lists.</p>
<p >These global states are described below:</p>
<div class="image">
<img src="https://user-images.githubusercontent.com/11412210/195989701-2b393456-db3c-42e8-b104-b99ce9f80f94.png" alt=""/>
<div class="caption">
Task global states</div></div>
<ul>
<li><code>qWaiting</code> : The task cannot run because the conditions for running are not in place.</li>
<li><code>qReady</code> : The task has completed preparations for running, but cannot run because a task with a higher precedence is running.</li>
<li><code>qRunning</code> : The task is currently being executed.</li>
<li><code>qSuspended</code> : The task doesn't take part in what is going on. Normally this state is taken after the <code>qRunning</code> state or when the task does not reach the <code>qReady</code> state.</li>
</ul>
<p >The presence of a task in a particular list indicates the task's state. There are many ready-lists as defined in the <code>Q_PRIORITY_LEVELS</code> macro. To select the target ready list, the OS use the user-assigned priority between 0 (the lowest priority) and <code>Q_PRIORITY_LEVELS-1</code> (the highest priority). For instance, if <code>Q_PRIORITY_LEVELS</code> is set to 5, then QuarkTS will use 5 priority levels or ready lists: 0 (lowest priority), 1, 2, 3, and 4 (highest priority).</p>
<div class="image">
<img src="https://user-images.githubusercontent.com/11412210/195989816-e03a419e-795f-4afc-8152-0ff45cef87c4.png" alt=""/>
<div class="caption">
OS lists</div></div>
<p >Except for the idle task, a task exists in one of these states. As the real-time embedded system runs, each task moves from one state to another (moving it from a list to another), according to the logic of a simple finite state machine (FSM). The figure below illustrates the typical flowchart used by QuarkTS to handle the task's states, with brief descriptions of state transitions, additionally you may also notice the interaction between the scheduler and the dispatcher.</p>
<p >The OS assumes that none of the tasks does a block anywhere during the <code>qRunning</code> state. Based on the round-robin fashion, each ready task runs in turn from every ready lists. The developer should take care to monitor their system execution times to make sure during the worst case, when all tasks have to execute, all of the deadlines are still met.</p>
<h2><a class="anchor" id="q_osrules"></a>
Rules</h2>
<p >Task precedence is used as the task scheduling rule and precedence among tasks is determined based on the priority of each task. If there are multiple tasks able to run, the one with the highest precedence goes to <code>qRunning</code> state first.</p>
<p >In determining precedence among tasks, of those tasks having different priority levels, that with the highest priority has the highest precedence. Among tasks having the same priority, the one that entered the scheduling scheme first has the highest precedence if the <code>Q_PRESERVE_TASK_ENTRY_ORDER</code> configuration is enabled, otherwise the OS will reserves for himself the order according to the dynamics of the kernel lists.</p>
<h3><a class="anchor" id="q_os_evenprecedence"></a>
Event precedence</h3>
<p >The scheduler also has an order of precedence for incoming events, in this way, if events of different nature converge to a single task, these will be served according to the following flowchart:</p>
<div class="image">
<img src="https://user-images.githubusercontent.com/11412210/195989877-d4b36a38-6a91-4615-967a-7b78898b96ec.png" alt=""/>
<div class="caption">
Event precedence</div></div>
<h3><a class="anchor" id="q_os_operational_states"></a>
Additional operational states</h3>
<p >Each task has independent operating states from those globally controlled by the scheduler. These states can be handled by the application writer to modify the event-flow to the task and consequently, affecting the transition to the <code>qReady</code> global state. These states are described as follows:</p>
<ul>
<li><code>qAwake</code> : In this state, the task is conceptually in an alert mode, handling most of the available events. This operational state is available when the <code>SHUTDOWN</code> bit is set, allowing the next operational states to be available:<ul>
<li><code>qEnabled</code> : The task is able to catch all the events. This operational state is available when the <code>ENABLE</code> bit is set.</li>
<li><code>qDisabled</code> : In this state the time events will be discarded. This operational state is available when the <code>ENABLE</code> bit is cleared.</li>
</ul>
</li>
<li><code>qAsleep</code> : Task operability is put into a deep doze mode, so the task can not be triggered by the lower precedence events. This operational state is available when the <code>SHUTDOWN</code> bit is cleared. The task can exit from this operational state when it receives a high precedence event (a queued notification) or using the <a class="el" href="group__qtaskmanip.html#ga5d9970617573cd8c14ed9a905d9c6a3a" title="Set the task operational state (Enabled or Disabled)">qTask_Set_State()</a> API.</li>
</ul>
<p >The figure bellow shows a better representation of how the event flow can be affected by this operational states.</p>
<div class="image">
<img src="https://user-images.githubusercontent.com/11412210/195989955-464a3eaf-c19f-4f27-bf83-21953358b3c2.png" alt=""/>
<div class="caption">
Event flow according operational states</div></div>
<dl class="section remark"><dt>Remarks</dt><dd>Queued notifications are the only event that can wake up sleeping tasks </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>qAsleep</code> operational state overrides the <code>qEnabled</code> and <code>qDisabled</code> states.</dd></dl>
<h1><a class="anchor" id="q_gettingstarted"></a>
Getting started</h1>
<p >Unpack the source files and copy them into your project. Also, add a copy of the file <code>qconfig.h</code> and modify it according to your needs. Setup your compiler include path with the corresponding OS directory. Include the header file <code><a class="el" href="_quark_t_s_8h_source.html">QuarkTS.h</a></code> and setup the instance of the kernel using the <a class="el" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313" title="Task Scheduler Setup. This function is required and must be called once in the application main threa...">qOS_Setup()</a> inside the main thread. Additional configuration to the target compiler may be required to add the path to the directory of header files. The code below shows a common initialization in the main source file.</p>
<p >File <code>main.c</code> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;QuarkTS.h&quot;</span></div>
<div class="line"><span class="preprocessor">#define TIMER_TICK 0.001 </span><span class="comment">// 1ms</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main( <span class="keywordtype">void</span> ) {</div>
<div class="line">    <span class="comment">//device startup with hardware-specific code</span></div>
<div class="line">    HardwareSetup();</div>
<div class="line">    Configure_Periodic_Timer_Interrupt_1ms();</div>
<div class="line">    <span class="comment">//end of device startup with hardware-specific code</span></div>
<div class="line">    <a class="code hl_function" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313">qOS_Setup</a>( NULL , TIMER_TICK , IdleTask_Callback );</div>
<div class="line">    <span class="comment">// TODO: add Tasks to the scheduler scheme and run the OS</span></div>
<div class="line">}</div>
</div><!-- fragment --><p >In the above code, the following considerations should be taken:</p><ul>
<li>The function <a class="el" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313" title="Task Scheduler Setup. This function is required and must be called once in the application main threa...">qOS_Setup()</a> must be called before any interaction with the OS.</li>
<li>The procedure HardwareSetup() should be a function with all the hardware instructions needed to initialize the target system.</li>
<li>The procedure <code>Configure_Periodic_Timer_Interrupt_1ms()</code> should be a function with all the hardware instructions needed to initialize and enable a timer with an overflow tick of one millisecond.</li>
</ul>
<p >Tasks can be later added to the scheduling scheme by simply calling <a class="el" href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2" title="Add a task to the scheduling scheme. The task is scheduled to run every t seconds,...">qOS_Add_Task()</a> or any of the other available APIs for specific purpose tasks.</p>
<h1><a class="anchor" id="q_critical"></a>
Critical sections</h1>
<p >Since the kernel is non-preemptive, the only critical section that must be handled are the shared resources accessed from the ISR context. Perhaps, the most obvious way of achieving mutual exclusion is to allow the kernel to disable interrupts before it enters its critical section and then, enable interrupts after it leaves its critical section.</p>
<p >By disabling interrupts, the CPU will be unable to change the current context. This guarantees that the currently running job can use a shared resource without another context accessing it. But, disabling interrupts, is a major undertaking. At best, the system will not be able to service interrupts for the time the current job is doing in its critical section, however, in QuarkTS, these critical sections are handled as quickly as possible.</p>
<p >Considering that the kernel is hardware-independent, the application writer should provide the necessary piece of code to enable and disable interrupts.</p>
<p >For this, the <a class="el" href="group__qcritical.html#gab60b5a86642800f3c4d733167d79dace" title="Set the hardware-specific code for global interrupt enable/disable. Setting this allows you to commun...">qCritical_SetInterruptsED()</a> API should be used. In this way, communication between ISR and tasks using queued notifications or data queues is performed safely.</p>
<p >In some systems, disabling the global IRQ flags is not enough, as they don't save/restore state of interrupt, so here, the <code>qUINT32_t</code> argument and return value in both functions (<code>Disabler</code> and <code>Restorer</code>) becomes relevant, because they can be used by the application writer to save and restore the current interrupt configuration. So, when a critical section is performed, the <code>Disabler</code>, in addition to disable the interrupts, returns the current configuration to be retained by the kernel, later when the critical section finish, this retained value is passed to Restorer to bring back the saved configuration.</p>
<h1><a class="anchor" id="q_os_demo"></a>
Demonstrative examples</h1>
<h2><a class="anchor" id="q_os_example1"></a>
A simple scheduling</h2>
<p >This example demonstrates a simple environment setup for multiple tasks. Initially, only <code>task1</code> and <code>task2</code> are enabled. <code>task1</code> runs every 2 seconds 10 times and then stops. <code>task2</code> runs every 3 seconds indefinitely. <code>task1</code> enables <code>task3</code> at its first run. <code>task3</code> run every 5 seconds. <code>task1</code> disables <code>task3</code> on its last iteration and changed <code>task2</code> to run every 1/2 seconds. In the end, <code>task2</code> is the only task running every 1/2 seconds.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;BSP.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;QuarkTS.h&quot;</span></div>
<div class="line"><span class="preprocessor">#define TIMER_TICK   0.001   </span><span class="comment">/* 1ms */</span><span class="preprocessor"> </span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structq_task__t.html">qTask_t</a> task1, task2, task3; <span class="comment">/*task nodes*/</span></div>
<div class="line"><span class="comment">/*==================================================================*/</span></div>
<div class="line"><span class="keywordtype">void</span> interrupt Timer0_ISR( <span class="keywordtype">void</span> ) {</div>
<div class="line">    <a class="code hl_function" href="group__qclock.html#gacdc3d27983dcc08e28d9eb9844a55c53">qClock_SysTick</a>();   </div>
<div class="line">}</div>
<div class="line"><span class="comment">/*==================================================================*/</span></div>
<div class="line"><span class="keywordtype">void</span> Task1_Callback( <a class="code hl_struct" href="structq_event__t.html">qEvent_t</a> e ) {</div>
<div class="line">    BSP_UART1_WriteString( <span class="stringliteral">&quot;Task1&quot;</span> );</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> ( e-&gt;<a class="code hl_variable" href="structq_event__t.html#a7b0ca3c3b637735eeee1f1e9d1105726">FirstIteration</a> ) {</div>
<div class="line">        <a class="code hl_define" href="group__qtaskmanip.html#gae5b5bcd7257f31ec290b600fe306adbe">qTask_Resume</a>( &amp;Task3 );    </div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> ( e-&gt;<a class="code hl_variable" href="structq_event__t.html#af000312a956c600f57074345a75536bf">LastIteration</a> ) {</div>
<div class="line">        <a class="code hl_define" href="group__qtaskmanip.html#ga1211609f7dba8749ae31aa73a8b072e6">qTask_Suspend</a>( &amp;Task3 );</div>
<div class="line">        <a class="code hl_function" href="group__qtaskmanip.html#ga27aa23ec76dae5afb4c1a4d8b8d8e256">qTask_Set_Time</a>( &amp;Task2, 0.5 );</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="comment">/*==================================================================*/</span></div>
<div class="line"><span class="keywordtype">void</span> Task2_Callback( <a class="code hl_struct" href="structq_event__t.html">qEvent_t</a> e ) {</div>
<div class="line">    BSP_UART1_WriteString( <span class="stringliteral">&quot;Task2&quot;</span> );</div>
<div class="line">}</div>
<div class="line"><span class="comment">/*==================================================================*/</span></div>
<div class="line"><span class="keywordtype">void</span> Task3_Callback( <a class="code hl_struct" href="structq_event__t.html">qEvent_t</a> e ) {</div>
<div class="line">    BSP_UART1_WriteString( <span class="stringliteral">&quot;Task3&quot;</span> );</div>
<div class="line">}</div>
<div class="line"><span class="comment">/*==================================================================*/</span></div>
<div class="line"><span class="keywordtype">int</span> main( <span class="keywordtype">void</span> ) {    </div>
<div class="line">    HardwareSetup();  <span class="comment">/*hardware initialization function*/</span></div>
<div class="line">    <span class="comment">/*function to fire an interrupt at 1ms - timer tick*/</span></div>
<div class="line">    Configure_Periodic_Timer0_Interrupt_1ms(); </div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313">qOS_Setup</a>( NULL, TIMER_TICK, NULL );     </div>
<div class="line">    <a class="code hl_function" href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2">qOS_Add_Task</a>( &amp;Task1, Task1_Callback, 50, 2.0, 10, <a class="code hl_define" href="group__qtypes.html#ga1743f4a545347fa50ab81f1e4e21b095">qEnabled</a>, NULL );</div>
<div class="line">    <a class="code hl_function" href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2">qOS_Add_Task</a>( &amp;Task2, Task2_Callback, 50, 3.0, <a class="code hl_define" href="group__qtaskcreation.html#gae3758e719245db560b090d90fce96301">qPeriodic</a>, <a class="code hl_define" href="group__qtypes.html#ga1743f4a545347fa50ab81f1e4e21b095">qEnabled</a>, NULL );</div>
<div class="line">    <a class="code hl_function" href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2">qOS_Add_Task</a>( &amp;Task2, Task3_Callback, 50, 5.0, <a class="code hl_define" href="group__qtaskcreation.html#gae3758e719245db560b090d90fce96301">qPeriodic</a>, <a class="code hl_define" href="group__qtypes.html#ga269b67aecf99613cea9e19c1c20a3037">qDisabled</a>, NULL );</div>
<div class="line">    <a class="code hl_function" href="group__qtaskcreation.html#gabd4b43371d39c5eb82b87f0900f2895a">qOS_Run</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__qtaskcreation_html_ga261c858990773b834e8129940ceef1e2"><div class="ttname"><a href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2">qOS_Add_Task</a></div><div class="ttdeci">qBool_t qOS_Add_Task(qTask_t *const Task, qTaskFcn_t callbackFcn, const qPriority_t p, const qTime_t t, const qIteration_t n, const qState_t init, void *arg)</div><div class="ttdoc">Add a task to the scheduling scheme. The task is scheduled to run every t seconds,...</div><div class="ttdef"><b>Definition:</b> qkernel.c:409</div></div>
<div class="ttc" id="agroup__qtaskcreation_html_gabd4b43371d39c5eb82b87f0900f2895a"><div class="ttname"><a href="group__qtaskcreation.html#gabd4b43371d39c5eb82b87f0900f2895a">qOS_Run</a></div><div class="ttdeci">qBool_t qOS_Run(void)</div><div class="ttdoc">Executes the scheduling scheme. It must be called once after the task pool has been defined.</div><div class="ttdef"><b>Definition:</b> qkernel.c:667</div></div>
<div class="ttc" id="agroup__qtaskcreation_html_gae3758e719245db560b090d90fce96301"><div class="ttname"><a href="group__qtaskcreation.html#gae3758e719245db560b090d90fce96301">qPeriodic</a></div><div class="ttdeci">#define qPeriodic</div><div class="ttdoc">A directive indicating that the task will run every time its timeout has expired.</div><div class="ttdef"><b>Definition:</b> qkernel.h:78</div></div>
<div class="ttc" id="agroup__qtaskmanip_html_ga1211609f7dba8749ae31aa73a8b072e6"><div class="ttname"><a href="group__qtaskmanip.html#ga1211609f7dba8749ae31aa73a8b072e6">qTask_Suspend</a></div><div class="ttdeci">#define qTask_Suspend(Task)</div><div class="ttdoc">Put the task into a disabled state.</div><div class="ttdef"><b>Definition:</b> qtasks.h:530</div></div>
<div class="ttc" id="agroup__qtaskmanip_html_ga27aa23ec76dae5afb4c1a4d8b8d8e256"><div class="ttname"><a href="group__qtaskmanip.html#ga27aa23ec76dae5afb4c1a4d8b8d8e256">qTask_Set_Time</a></div><div class="ttdeci">qBool_t qTask_Set_Time(qTask_t *const Task, const qTime_t tValue)</div><div class="ttdoc">Set/Change the Task execution interval.</div><div class="ttdef"><b>Definition:</b> qtasks.c:95</div></div>
<div class="ttc" id="agroup__qtaskmanip_html_gae5b5bcd7257f31ec290b600fe306adbe"><div class="ttname"><a href="group__qtaskmanip.html#gae5b5bcd7257f31ec290b600fe306adbe">qTask_Resume</a></div><div class="ttdeci">#define qTask_Resume(Task)</div><div class="ttdoc">Put the task into an enabled state.</div><div class="ttdef"><b>Definition:</b> qtasks.h:546</div></div>
<div class="ttc" id="agroup__qtypes_html_ga1743f4a545347fa50ab81f1e4e21b095"><div class="ttname"><a href="group__qtypes.html#ga1743f4a545347fa50ab81f1e4e21b095">qEnabled</a></div><div class="ttdeci">#define qEnabled</div><div class="ttdoc">A state value that enables a task.</div><div class="ttdef"><b>Definition:</b> qtypes.h:167</div></div>
<div class="ttc" id="agroup__qtypes_html_ga269b67aecf99613cea9e19c1c20a3037"><div class="ttname"><a href="group__qtypes.html#ga269b67aecf99613cea9e19c1c20a3037">qDisabled</a></div><div class="ttdeci">#define qDisabled</div><div class="ttdoc">A state value that disables a task.</div><div class="ttdef"><b>Definition:</b> qtypes.h:172</div></div>
<div class="ttc" id="astructq_event__t_html_a7b0ca3c3b637735eeee1f1e9d1105726"><div class="ttname"><a href="structq_event__t.html#a7b0ca3c3b637735eeee1f1e9d1105726">qEvent_t::FirstIteration</a></div><div class="ttdeci">qBool_t FirstIteration</div><div class="ttdoc">Indicates whether current pass is the first iteration of the task. This flag will be only set when ti...</div><div class="ttdef"><b>Definition:</b> qtasks.h:190</div></div>
<div class="ttc" id="astructq_event__t_html_af000312a956c600f57074345a75536bf"><div class="ttname"><a href="structq_event__t.html#af000312a956c600f57074345a75536bf">qEvent_t::LastIteration</a></div><div class="ttdeci">qBool_t LastIteration</div><div class="ttdoc">Indicates whether current pass is the last iteration of the task. This flag will be only set when tim...</div><div class="ttdef"><b>Definition:</b> qtasks.h:198</div></div>
</div><!-- fragment --><h2><a class="anchor" id="q_os_example2"></a>
Using the task argument</h2>
<p >When adding tasks, they can accept a parameter of type pointer to void <code>void*</code> also called the storage pointer. This parameter could be used for multiple applications, including storage, task identification, duplication removal and others. The following example shows the usage of this argument to avoid callback duplication among tasks with the same behavior.</p>
<p >Consider a scenario where you have to build a digital controller for several physical variables, for example, a PID controller for temperature, humidity and light. The PID algorithm will be the same for all variables. The only difference will be the variable input, the controlled output action and the PID gains. In this case, each of the PID tasks will utilize the same callback methods. The only difference will be the I/O parameters (specific for each PID controller).</p>
<p >Let’s define a PID data structure with the I/O variables and gains.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>{</div>
<div class="line">     <span class="keywordtype">float</span> yt; <span class="comment">/*Measured variable (Controller Input)*/</span></div>
<div class="line">     <span class="keywordtype">float</span> ut; <span class="comment">/*Controlled variable (Controller Output)*/</span></div>
<div class="line">     <span class="keywordtype">float</span> ie; <span class="comment">/*Accumulated error*/</span></div>
<div class="line">     <span class="keywordtype">float</span> pe; <span class="comment">/*Previous error*/</span></div>
<div class="line">     <span class="keywordtype">float</span> dt; <span class="comment">/*Controller Time Step*/</span></div>
<div class="line">     <span class="keywordtype">float</span> sp; <span class="comment">/*Set-Point*/</span></div>
<div class="line">     <span class="keywordtype">float</span> Kc, Ki, Kd; <span class="comment">/*PID Gains*/</span> </div>
<div class="line"> }PID_Params_t;</div>
<div class="line"> </div>
<div class="line"> PID_Params_t TemperatureControl = {</div>
<div class="line">    0,0,0,0, <span class="comment">/*Initial IO state of yt and ut*/</span></div>
<div class="line">    1.5, <span class="comment">/*time step*/</span></div>
<div class="line">    28.5, <span class="comment">/*Set-Point*/</span></div>
<div class="line">    0.89, 0.122, 0.001 <span class="comment">/*Kc, Ki, Kd*/</span></div>
<div class="line"> };</div>
<div class="line"> PID_Params_t HumidityControl= {</div>
<div class="line">    0,0,0,0, <span class="comment">/*Initial IO state of yt and ut*/</span></div>
<div class="line">    1, <span class="comment">/*time step*/</span></div>
<div class="line">    60.0, <span class="comment">/*Set-Point*/</span></div>
<div class="line">    2.5, 0.2354, 0.0015 <span class="comment">/*Kc, Ki, Kd*/</span></div>
<div class="line"> };</div>
<div class="line"> PID_Params_t LightControl= {</div>
<div class="line">    0,0,0,0, <span class="comment">/*Initial IO state of yt and ut*/</span></div>
<div class="line">    0.5, <span class="comment">/*time step*/</span></div>
<div class="line">    45.0, <span class="comment">/*Set-Point*/</span></div>
<div class="line">    5.36, 0.0891, 0.0 <span class="comment">/*Kc, Ki, Kd*/</span></div>
<div class="line"> };</div>
</div><!-- fragment --><p >A task will be added to the scheme to collect the sensor data and apply the respective control output.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2">qOS_Add_Task</a>( &amp;IO_TASK , IO_TASK_Callback , <a class="code hl_define" href="group__qtaskcreation.html#ga13bec7f4284d45c97f512c83ed9b7744">qMedium_Priority</a> , 0.1, <a class="code hl_define" href="group__qtaskcreation.html#gae3758e719245db560b090d90fce96301">qPeriodic</a>, <a class="code hl_define" href="group__qtypes.html#ga1743f4a545347fa50ab81f1e4e21b095">qEnabled</a> , <span class="stringliteral">&quot;iotask&quot;</span>);</div>
<div class="ttc" id="agroup__qtaskcreation_html_ga13bec7f4284d45c97f512c83ed9b7744"><div class="ttname"><a href="group__qtaskcreation.html#ga13bec7f4284d45c97f512c83ed9b7744">qMedium_Priority</a></div><div class="ttdeci">#define qMedium_Priority</div><div class="ttdoc">A macro directive to indicate the medium priority level.</div><div class="ttdef"><b>Definition:</b> qkernel.h:72</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> IO_TASK_Callback( <a class="code hl_struct" href="structq_event__t.html">qEvent_t</a> e ) {</div>
<div class="line">    TemperatureControl.yt  = SampleTemperatureSensor();</div>
<div class="line">    HumidityControl.yt  = SampleHumiditySensor();</div>
<div class="line">    LightControl.yt  = SampleLightSensor();</div>
<div class="line">    WriteTemperatureActuatorValue( TemperatureControl.ut );</div>
<div class="line">    WriteHumidityActuatorValue( HumidityControl.ut );</div>
<div class="line">    WriteLightActuatorValue( LightControl.ut ); </div>
<div class="line">}</div>
</div><!-- fragment --><p >Then, three different tasks are created to apply the respective PID controller. Note that these tasks refer to the same callback methods and we assign pointers to the respective variables.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2">qOS_Add_Task</a>( &amp;TEMPERATURE_CONTROL_TASK, PIDControl_Callback,</div>
<div class="line">              <a class="code hl_define" href="group__qtaskcreation.html#ga32c8bd0870414e10a6e72b743627da5a">qHigh_Priority</a>, TemperatureControl.dt , </div>
<div class="line">              <a class="code hl_define" href="group__qtaskcreation.html#gae3758e719245db560b090d90fce96301">qPeriodic</a>, <a class="code hl_define" href="group__qtypes.html#ga1743f4a545347fa50ab81f1e4e21b095">qEnabled</a>, &amp;TemperatureControl );</div>
<div class="line"><a class="code hl_function" href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2">qOS_Add_Task</a>( &amp;HUMIDITY_CONTROL_TASK, PIDControl_Callback, </div>
<div class="line">              <a class="code hl_define" href="group__qtaskcreation.html#ga32c8bd0870414e10a6e72b743627da5a">qHigh_Priority</a>, HumidityControl.dt, </div>
<div class="line">              <a class="code hl_define" href="group__qtaskcreation.html#gae3758e719245db560b090d90fce96301">qPeriodic</a>, <a class="code hl_define" href="group__qtypes.html#ga1743f4a545347fa50ab81f1e4e21b095">qEnabled</a>, &amp;HumidityControl );</div>
<div class="line"><a class="code hl_function" href="group__qtaskcreation.html#ga261c858990773b834e8129940ceef1e2">qOS_Add_Task</a>( &amp;LIGHT_CONTROL_TASK, PIDControl_Callback, </div>
<div class="line">              <a class="code hl_define" href="group__qtaskcreation.html#ga32c8bd0870414e10a6e72b743627da5a">qHigh_Priority</a>, LightControl.dt, </div>
<div class="line">              <a class="code hl_define" href="group__qtaskcreation.html#gae3758e719245db560b090d90fce96301">qPeriodic</a>, <a class="code hl_define" href="group__qtypes.html#ga1743f4a545347fa50ab81f1e4e21b095">qEnabled</a>, &amp;LightControl );</div>
<div class="ttc" id="agroup__qtaskcreation_html_ga32c8bd0870414e10a6e72b743627da5a"><div class="ttname"><a href="group__qtaskcreation.html#ga32c8bd0870414e10a6e72b743627da5a">qHigh_Priority</a></div><div class="ttdeci">#define qHigh_Priority</div><div class="ttdoc">A macro directive to indicate the highest priority level.</div><div class="ttdef"><b>Definition:</b> qkernel.h:75</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> PIDControl_Callback( <a class="code hl_struct" href="structq_event__t.html">qEvent_t</a> e ) {</div>
<div class="line">    <span class="keywordtype">float</span> Error, derivative;</div>
<div class="line">    <span class="comment">/* Obtain the reference to the specific PID controller </span></div>
<div class="line"><span class="comment">     * using the TaskData field from the qEvent structure</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    PID_Params_t *Controller = (PID_Params_t *)e-&gt;<a class="code hl_variable" href="structq_event__t.html#a191262c05958798bbb47391043170b2a">TaskData</a>; </div>
<div class="line">    <span class="comment">/*Compute the error*/</span></div>
<div class="line">    Error = Controller-&gt;sp - Controller-&gt;yt;</div>
<div class="line">    <span class="comment">/*Compute the accumulated error using backward integral approximation*/</span></div>
<div class="line">    Controller-&gt;ie += Error*Controller-&gt;dt;</div>
<div class="line">    <span class="comment">/*update and compute the derivative term*/</span></div>
<div class="line">    derivative = (Error - Controller-&gt;pe)/Controller-&gt;dt;</div>
<div class="line">    <span class="comment">/*update the previous error*/</span></div>
<div class="line">    Controller-&gt;pe = Error;</div>
<div class="line">    <span class="comment">/*compute the pid control law*/</span></div>
<div class="line">    Controller-&gt;ut = Controller-&gt;Kc*Error  +  </div>
<div class="line">                     Controller-&gt;Ki*Controller-&gt;ie + </div>
<div class="line">                     Controller-&gt;Kd*derivative;</div>
<div class="line">}</div>
<div class="ttc" id="astructq_event__t_html_a191262c05958798bbb47391043170b2a"><div class="ttname"><a href="structq_event__t.html#a191262c05958798bbb47391043170b2a">qEvent_t::TaskData</a></div><div class="ttdeci">void * TaskData</div><div class="ttdoc">Task arguments defined at the time of its creation. (Storage-Pointer)</div><div class="ttdef"><b>Definition:</b> qtasks.h:164</div></div>
</div><!-- fragment --><h1><a class="anchor" id="q_configmacros"></a>
Configuration macros</h1>
<p >Some OS features can be customized using a set of macros located in the header file <code>qconfig.h</code>. Here is the default configuration, followed by an explanation of each macro:</p>
<ul>
<li><code>Q_PRIORITY_LEVELS</code> : <em>Default:</em> <code>3</code>. The number of priorities available for application tasks.</li>
<li><code>Q_SETUP_TIME_CANONICAL</code> : <em>Default:</em> <code>0</code>(disabled). If enabled, the kernel assumes the timing base to 1mS(1KHz). So all time specifications for tasks and STimers must be set in milliseconds(mS). Also can be used to remove the floating-point operations when dealing with time. In some systems, can reduce the memory usage.</li>
<li><code>Q_SETUP_TICK_IN_HERTZ</code> : <em>Default:</em> <code>0</code>(disabled). If enabled, the timing base will be taken as frequency(Hz) instead of period(S) by <a class="el" href="group__qtaskcreation.html#gac97ca3bd669135e0adcf07fcc2852313" title="Task Scheduler Setup. This function is required and must be called once in the application main threa...">qOS_Setup()</a> (In some systems, can reduce the memory usage ).</li>
<li><code>Q_PRIO_QUEUE_SIZE</code> : <em>Default:</em> <code>10</code>. Size of the priority queue for notifications. This argument should be an integer number greater than zero. A zero value can be used to disable this functionality.</li>
<li><code>Q_PRESERVE_TASK_ENTRY_ORDER</code> : <em>Default:</em> <code>0</code>(disabled). If enabled, the kernel will preserve the tasks entry order every OS scheduling cycle.</li>
<li><code>Q_MEMORY_MANAGER</code> : <em>Default:</em> <code>1</code>(enabled). Used to enable or disable the memory management module.</li>
<li><code>Q_BYTE_ALIGNMENT</code> : <em>Default:</em> <code>8</code>. Used by the memory management module to perform the byte-alignment.</li>
<li><code>Q_DEFAULT_HEAP_SIZE</code> : <em>Default:</em> <code>2048</code>. The total amount of heap size for the default memory pool.</li>
<li><code>Q_NOTIFICATION_SPREADER</code> : <em>Default:</em> <code>0</code>(disabled). Used to enable or disable the spread notification functionality.</li>
<li><code>Q_FSM</code> : <em>Default:</em> <code>1</code>(enabled). Used to enable or disable the Finite State Machine (FSM) extension.</li>
<li><code>Q_FSM_MAX_NEST_DEPTH</code> : <em>Default:</em> <code>5</code>. The max depth of nesting in Finite State Machines (FSM).</li>
<li><code>Q_FSM_MAX_TIMEOUTS</code> : <em>Default:</em> <code>3</code>. Max number of timeouts inside a timeout specification for the Finite State machine (FSM) module.</li>
<li><code>Q_QUEUES</code> : <em>Default:</em> <code>1</code>(enabled). Used to enable or disable the queues APIs for inter-task communication.</li>
<li><code>Q_TRACE_VARIABLES</code> : <em>Default:</em> <code>1</code>(enabled). Used to enable or disable debug and trace macros.</li>
<li><code>Q_DEBUGTRACE_BUFSIZE</code> : <em>Default:</em> <code>36</code>. The buffer size for debug and trace macros</li>
<li><code>Q_DEBUGTRACE_FULL</code> : <em>Default:</em> <code>1</code>(enabled). Used to enable of disable the extended output for trace macros.</li>
<li><code>Q_ATCLI</code> : <em>Default:</em> <code>1</code>(enabled). Used to enable or disable the AT Command Line Interface (CLI) module.</li>
<li><code>Q_TASK_COUNT_CYCLES</code> : <em>Default:</em> <code>0</code>(disabled). Used to enable or disable the counting of cycler of a task.</li>
<li><code>Q_TASK_EVENT_FLAGS</code> : <em>Default:</em> <code>1</code>(enabled). Used to enable or disable the task event flags.</li>
<li><code>Q_MAX_FTOA_PRECISION</code> : <em>Default:</em> <code>10</code>. The default precision used to perform float to ASCII conversions.</li>
<li><code>Q_ATOF_FULL</code> : <em>Default:</em> <code>0</code>(disabled). Used to enable or disable the scientific notation in ASCII to float conversions.</li>
<li><code>Q_ALLOW_SCHEDULER_RELEASE</code> : <em>Default:</em> <code>0</code>(disabled). Used to enable or disable the scheduler release functionality.</li>
<li><code>Q_RESPONSE_HANDLER</code> : <em>Default:</em> <code>1</code>(enabled). Used to enable or disable the response handler functionality.</li>
<li><code>Q_EDGE_CHECK_IOGROUPS</code> : <em>Default:</em> <code>1</code>(enabled). Used to enable or disable the edge check functionality for I/O groups .</li>
<li><code>Q_BYTE_SIZED_BUFFERS</code> : <em>Default:</em> <code>1</code>(enabled). Used to enable or disable the usage of Byte-sized buffers.</li>
<li><code>Q_USE_STDINT_H</code> : <em>Default:</em> <code>1</code>(enabled). Use the <code>stdint.h</code> header to define kernel data-types. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">QuarkTS OS</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
